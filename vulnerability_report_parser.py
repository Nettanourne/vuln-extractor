import argparse
from pathlib import Path
import json
from collections import Counter, defaultdict


def process_file(input_path, output_path=None, histogram_path=None, source=None):
    # Open file with handling errors
    try:
        with input_path.open('r', encoding='utf-8') as file:
            content = json.load(file)
    except (FileNotFoundError, json.JSONDecodeError) as e:
        print(f"Error loading JSON: {e}")
        return

    # Creating empty structures for collecting and counting vulnerabilities
    processed_data = defaultdict(list)
    histogram_data = Counter()

    # Cycle goes through the input file, collects vulnerabilities, and counts them
    for item in content["dependencies"]:
        if "vulnerabilities" not in item:
            continue
        else:
            for field in item["vulnerabilities"]:
                if field.get("source") == source:
                    # Handling cases of unknown or missing severity
                    severity = field.get("severity", "UNKNOWN").upper()
                    # Handling cases of empty or missing fileName field
                    file_name = item.get("fileName", "UNKNOWN") or "UNKNOWN"
                    # Handling cases of unknown or missing vulnerability name
                    vuln_name = field.get("name", "UNKNOWN").upper()

                    key = (vuln_name, severity)
                    if key not in processed_data:
                        histogram_data[severity] += 1
                    processed_data[key].append(file_name)
                else:
                    continue

    # creating sorting priority
    severity_order = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3, "NONE": 4, "UNKNOWN": 5}

    # Sorting and serialization of histogram data into target format
    histogram_prepared = [
        {"severity": key, "num_vulnerabilities": value}
        for key, value in histogram_data.items()
    ]
    histogram_prepared.sort(key=lambda x: severity_order.get(x["severity"], 99))
    histogram_serialized = json.dumps(histogram_prepared, indent=4)

    # Output for histogram, file or console
    if histogram_path:
        with histogram_path.open('w', encoding='utf-8') as file:
            json.dump(histogram_prepared, file, indent=4)
        print(f"Severity Histogram generated in: {histogram_path}")
    else:
        print("Severity Histogram generated:")
        print(histogram_serialized)

    # Sorting and serialization of report data into target format
    report_prepared = [
        {
            "vulnerability_name": key[0],
            "severity": key[1],
            "file_names": value
        }
        for key, value in processed_data.items()
    ]
    report_prepared.sort(key=lambda x: severity_order.get(x["severity"], 99))
    report_serialized = json.dumps(report_prepared, indent=4)

    # Output for histogram, file or console
    if output_path:
        with output_path.open('w', encoding='utf-8') as file:
            json.dump(report_prepared, file, indent=4)
        print(f"Vulnerabilities extracted and sorted in: {output_path}")
    else:
        print("Vulnerabilities extracted and sorted:")
        print(report_serialized)


def main():
    # Parsing command line args
    parser = argparse.ArgumentParser(description="OWASP Dependency-Check report Vulnerabilities Extractor and Sorter.")

    parser.add_argument('input', type=str, help='Path to input file.')
    parser.add_argument('-o', '--output', type=str, help='Path to output file (optional), if empty - '
                                                         'report will be shown in runtime window).')
    parser.add_argument('-g', '--histogram', type=str, help='Path to output histogram file (optional, if empty - '
                                                            'histogram will be shown in runtime window).')
    parser.add_argument('-s', '--source', type=str, help='Source of vulnerabilities data "NVD", "OSSINDEX", '
                                                         '"RETIREJS", "NPM" (optional, default - "NVD").')
    args = parser.parse_args()

    # Check the existence of the input file
    input_path = Path(args.input)
    if not input_path.is_file():
        print(f"Error: input file '{input_path}' not found.")
        return

    source = str(args.source) if args.source else "NVD"
    output_path = Path(args.output) if args.output else None
    histogram_path = Path(args.histogram) if args.histogram else None

    process_file(input_path, output_path, histogram_path, source)


if __name__ == '__main__':
    main()
